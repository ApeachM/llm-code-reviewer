# Implementation Plan: Core PR Review Engine

**Branch**: `001-pr-review-core` | **Date**: 2025-11-11 | **Spec**: [001-pr-review-core.md](../specifications/001-pr-review-core.md)
**Input**: Feature specification from `.specify/specifications/001-pr-review-core.md`

## Summary

Build a local LLM-powered C++ code review tool that analyzes pull request diffs using Ollama models. The tool must detect git context, extract C++ file changes, send code to local Ollama for review, and output structured feedback in multiple formats (markdown, JSON, git-comment compatible). Primary focus: privacy-first (all local), git-native integration, and actionable C++-specific feedback.

## Technical Context

**Language/Version**: Python 3.11+
**Primary Dependencies**:
- `ollama` - Python SDK for Ollama API
- `GitPython` or `pygit2` - Git repository interaction
- `typer` - Modern CLI framework with rich output
- `rich` - Terminal formatting and progress display
- `pydantic` - Data validation and settings management
- `jinja2` - Template engine for output formatting

**Storage**: File-based configuration (`.cpp-reviewer.yml`), no database required
**Testing**: `pytest` with git repository fixtures, mock Ollama responses
**Target Platform**: Linux/macOS/Windows, Python 3.11+ environments
**Project Type**: Single CLI application with library components
**Performance Goals**:
- < 5s startup and git context extraction
- < 2min for 500-line PR with deepseek-coder:33b
- Streaming output for real-time feedback

**Constraints**:
- All processing must be local (no external API calls except git forge integrations)
- Must work offline when Ollama is available
- Timeout protection: max 10 minutes per review
- Memory efficient: stream large diffs rather than loading entirely

**Scale/Scope**:
- Support PRs up to 2000 lines changed
- Handle repositories with 100k+ LOC
- Process 10-50 files per review typically

## Constitution Check

*GATE: Must pass before implementation begins*

✅ **Privacy-First, Local LLM Only**: All review logic uses Ollama, no cloud API calls
✅ **Git-Native Integration**: Core functionality is diff extraction and git context detection
✅ **C++ Code Quality Focus**: Prompt engineering and categorization focused on C++ best practices
✅ **Actionable, Structured Output**: Multiple output formats (markdown, JSON, git-comment) specified
✅ **Extensible and Configurable**: Config file support and plugin architecture planned

No constitution violations. All principles satisfied by design.

## Project Structure

### Documentation (this feature)

```text
.specify/
├── specifications/
│   └── 001-pr-review-core.md     # Feature specification
├── plans/
│   └── 001-pr-review-core-plan.md # This file
└── tasks/
    └── 001-pr-review-core-tasks.md # Generated by /speckit.tasks
```

### Source Code (repository root)

```text
cpp-llm-reviewer/
├── src/
│   └── cpp_reviewer/
│       ├── __init__.py
│       ├── cli/
│       │   ├── __init__.py
│       │   └── main.py           # CLI entry point (typer app)
│       ├── git/
│       │   ├── __init__.py
│       │   ├── context.py        # GitContext model and extraction
│       │   └── diff_parser.py    # Parse git diffs into structured format
│       ├── llm/
│       │   ├── __init__.py
│       │   ├── ollama_client.py  # Ollama API client
│       │   └── prompts.py        # Prompt templates for C++ review
│       ├── review/
│       │   ├── __init__.py
│       │   ├── reviewer.py       # Core review orchestration
│       │   ├── comment.py        # Comment model and categorization
│       │   └── categories.py     # Define review categories
│       ├── output/
│       │   ├── __init__.py
│       │   ├── formatters.py     # Markdown, JSON, git-comment formatters
│       │   └── templates/        # Jinja2 templates
│       ├── config/
│       │   ├── __init__.py
│       │   └── settings.py       # Config file parsing and defaults
│       └── integrations/
│           ├── __init__.py
│           ├── github.py         # GitHub API integration
│           └── gitlab.py         # GitLab API integration
│
├── tests/
│   ├── unit/
│   │   ├── test_git_context.py
│   │   ├── test_diff_parser.py
│   │   ├── test_ollama_client.py
│   │   ├── test_reviewer.py
│   │   ├── test_formatters.py
│   │   └── test_config.py
│   ├── integration/
│   │   ├── test_full_review.py
│   │   └── test_git_integration.py
│   └── fixtures/
│       ├── sample_repos/         # Git repos with test PRs
│       └── mock_responses.json   # Mock Ollama responses
│
├── pyproject.toml                # Project metadata, dependencies
├── README.md                     # Installation and usage guide
├── .cpp-reviewer.yml.example     # Example config file
└── .gitignore

```

**Structure Decision**: Single Python project structure chosen because:
- CLI tool with library components, no frontend/backend split
- All functionality in one package for easy distribution via pip/uv
- Clear separation of concerns: git, llm, review, output, config, integrations
- Testable modular design with dependency injection

## Implementation Phases

### Phase 0: Project Setup & Infrastructure (Priority: P1)

**Goal**: Set up Python project, install dependencies, validate Ollama connectivity

**Tasks**:
1. Initialize Python project with `pyproject.toml` (use `uv` for modern dependency management)
2. Set up project structure (create all directories)
3. Configure pytest with fixtures for git repositories
4. Create basic CLI entry point with `typer`
5. Implement Ollama connectivity check
6. Write integration test: "Can connect to Ollama and list models"

**Deliverables**:
- Working Python environment with all dependencies
- `cpp-reviewer --version` and `cpp-reviewer --help` functional
- Test that validates Ollama connection

**Acceptance**: Running `pytest` passes all infrastructure tests

---

### Phase 1: Git Context Extraction (Priority: P1)

**Goal**: Detect git repository, extract PR/branch diff, identify changed C++ files

**Tasks**:
1. Implement `GitContext` model (pydantic) with fields: base_branch, head_commit, changed_files, diff
2. Implement git repository detection and validation
3. Implement diff extraction for current branch vs base (default: main/master)
4. Implement C++ file filtering (.cpp, .hpp, .cc, .h, .cxx, .hxx extensions)
5. Implement diff parsing to extract line-level changes with context
6. Write unit tests for diff parsing edge cases
7. Write integration test: "Extract diff from sample git repo"

**Deliverables**:
- `GitContext` class that can extract all necessary diff information
- Robust error handling for git errors (detached HEAD, no git repo, etc.)

**Acceptance**:
- Can extract diff from test repository with multiple C++ files
- Correctly identifies changed line numbers and context

---

### Phase 2: Ollama Integration & Prompt Engineering (Priority: P1)

**Goal**: Send code diffs to Ollama and receive structured review feedback

**Tasks**:
1. Implement `OllamaClient` class with methods: `list_models()`, `generate_review()`, `check_health()`
2. Design prompt template for C++ code review with categories
3. Implement prompt formatting: include file context, diff, and review guidelines
4. Implement streaming response handling
5. Implement response parsing to extract: file, line, category, severity, message, suggested_fix
6. Add retry logic and timeout protection (10min default)
7. Write unit tests with mocked Ollama responses
8. Write integration test: "Send real code to Ollama and parse response"

**Deliverables**:
- Working Ollama client that sends diffs and receives structured reviews
- Prompt templates that produce consistent, parseable output

**Acceptance**:
- Successfully sends 100-line C++ diff to deepseek-coder and receives categorized comments
- Handles malformed LLM responses gracefully

---

### Phase 3: Review Comment Model & Categorization (Priority: P1)

**Goal**: Structure review feedback into typed Comment objects with categories and severity

**Tasks**:
1. Implement `Comment` model (pydantic) with fields: file_path, line_number, category, severity, message, suggested_fix
2. Define review categories enum: memory_safety, modern_cpp, performance, style, security, concurrency
3. Define severity levels enum: critical, warning, suggestion, info
4. Implement categorization logic (parse LLM output into categories)
5. Implement filtering logic: `--focus` and `--exclude` flags
6. Write unit tests for comment validation and filtering
7. Write integration test: "Generate comments from LLM output and filter by category"

**Deliverables**:
- Typed `Comment` model with validation
- Category and severity enums
- Filtering functionality

**Acceptance**:
- Can parse LLM output into structured Comment objects
- Can filter comments by category using `--focus memory-safety`

---

### Phase 4: Output Formatting (Priority: P1)

**Goal**: Generate review output in multiple formats: markdown, JSON, git-comment

**Tasks**:
1. Implement markdown formatter using Jinja2 templates
2. Implement JSON formatter with schema definition
3. Implement git-comment formatter (file:line format)
4. Add `--format` CLI flag (choices: markdown, json, git-comment)
5. Add `--output` CLI flag to write to file instead of stdout
6. Implement rich terminal output with progress indicators
7. Write unit tests for each formatter
8. Write integration test: "Full review outputs valid JSON"

**Deliverables**:
- Three output formatters working correctly
- Rich terminal UI with progress bars
- JSON schema for programmatic parsing

**Acceptance**:
- JSON output validates against schema
- Markdown output is human-readable and well-formatted
- Git-comment format can be parsed by git forge tools

---

### Phase 5: Configuration System (Priority: P2)

**Goal**: Support `.cpp-reviewer.yml` config file for persistent settings

**Tasks**:
1. Implement `Settings` model (pydantic) with fields: model, focus, exclude_patterns, timeout, output_format
2. Implement config file discovery (current dir, parent dirs, home dir)
3. Implement config file parsing (YAML)
4. Implement CLI flag override logic (flags override config)
5. Create `.cpp-reviewer.yml.example` with documentation
6. Write unit tests for config parsing and override logic
7. Write integration test: "Config file settings are applied"

**Deliverables**:
- Working configuration system with sensible defaults
- Example config file with comments
- Documentation in README

**Acceptance**:
- Config file is loaded and settings are applied
- CLI flags correctly override config file settings

---

### Phase 6: CLI Implementation & User Experience (Priority: P1)

**Goal**: Implement full CLI with all flags, help text, and error handling

**Tasks**:
1. Implement `cpp-reviewer review` command with all flags:
   - `--base BRANCH` (default: main)
   - `--model MODEL` (default: deepseek-coder:33b-instruct)
   - `--format FORMAT` (default: markdown)
   - `--output FILE` (default: stdout)
   - `--focus CATEGORIES` (comma-separated)
   - `--exclude CATEGORIES` (comma-separated)
   - `--timeout SECONDS` (default: 600)
2. Implement rich error messages for common issues:
   - No git repository
   - Ollama not running
   - Model not found
   - No C++ files changed
3. Implement `cpp-reviewer models` command to list available Ollama models
4. Implement `cpp-reviewer config` command to show current configuration
5. Add comprehensive help text and examples
6. Write integration tests for CLI commands
7. Write user documentation in README

**Deliverables**:
- Fully functional CLI with all specified flags
- Helpful error messages
- User documentation

**Acceptance**:
- User can run `cpp-reviewer review` and get a complete review
- All CLI flags work as documented
- Error messages guide users to resolution

---

### Phase 7: GitHub/GitLab Integration (Priority: P3)

**Goal**: Post review comments directly to GitHub PRs and GitLab MRs

**Tasks**:
1. Implement GitHub API client using `PyGithub`
2. Implement GitLab API client using `python-gitlab`
3. Add `--github-pr NUMBER` flag
4. Add `--gitlab-mr NUMBER` flag
5. Add `--auto-detect-pr` flag (detect PR from branch)
6. Implement authentication via env vars (GH_TOKEN, GITLAB_TOKEN)
7. Implement comment posting with line-level feedback
8. Handle rate limiting and API errors gracefully
9. Write integration tests with mocked API responses
10. Document GitHub/GitLab setup in README

**Deliverables**:
- Working GitHub and GitLab integrations
- Documentation for authentication setup

**Acceptance**:
- Comments are successfully posted to GitHub PR
- Authentication errors are handled gracefully
- Works with both GitHub and GitLab

---

### Phase 8: Testing & Quality Assurance (Priority: P1)

**Goal**: Comprehensive test coverage and quality validation

**Tasks**:
1. Achieve >80% code coverage with pytest
2. Create end-to-end test: full review of sample C++ PR
3. Test with all supported Ollama models
4. Test with various C++ standards (C++11, C++17, C++20)
5. Stress test: large PR with 1000+ lines changed
6. Test error scenarios: timeout, malformed LLM output, git errors
7. Test on Linux, macOS, Windows environments
8. Run review on real-world C++ projects and validate quality

**Deliverables**:
- Test suite with >80% coverage
- Documented test scenarios
- Validation against real projects

**Acceptance**:
- All tests pass
- Tool successfully reviews real C++ PRs with useful feedback

---

### Phase 9: Documentation & Distribution (Priority: P1)

**Goal**: Package tool for distribution and write user documentation

**Tasks**:
1. Write comprehensive README with:
   - Installation instructions (uv, pip)
   - Quick start guide
   - Configuration reference
   - Examples for common workflows
   - Troubleshooting guide
2. Create example C++ projects with known issues for testing
3. Configure `pyproject.toml` for PyPI distribution
4. Create Docker image for CI/CD environments
5. Write CI/CD integration examples (GitHub Actions, GitLab CI)
6. Create CONTRIBUTING.md for future development
7. Add LICENSE file (MIT or Apache 2.0)

**Deliverables**:
- Published package to PyPI
- Docker image on Docker Hub
- Complete documentation
- CI/CD examples

**Acceptance**:
- Tool can be installed via `uv tool install cpp-llm-reviewer`
- Docker image runs successfully in CI environment
- Documentation is clear and examples work

---

## Risk Mitigation

**Risk 1**: LLM output is inconsistent or unparseable
- **Mitigation**: Use structured prompts with examples, implement robust parsing with fallbacks, test with multiple models

**Risk 2**: Large PRs timeout or run too slowly
- **Mitigation**: Implement chunking strategy, add progress indicators, make timeout configurable, optimize prompt size

**Risk 3**: Git edge cases cause failures (merge conflicts, detached HEAD, etc.)
- **Mitigation**: Comprehensive error handling, clear user-facing messages, test against many git scenarios

**Risk 4**: Different C++ standards require different review approaches
- **Mitigation**: Auto-detect C++ standard from file headers/flags, adjust prompts accordingly, make this configurable

**Risk 5**: Integration with GitHub/GitLab is complex and fragile
- **Mitigation**: Keep git forge integrations as optional P3 features, ensure tool works great without them, use well-maintained API clients

## Success Metrics

Implementing phases 0-6 delivers a fully functional MVP (P1 + P2 features).
Phase 7 (GitHub/GitLab) is optional enhancement.
Phase 8 & 9 ensure quality and distribution.

**MVP Definition**: Phases 0-6 complete
- Can run `cpp-reviewer review` on any git repository
- Extracts C++ diffs, sends to Ollama, outputs structured feedback
- Supports markdown/JSON output and configuration file
- < 2min for typical 500-line PR

**Full Release**: All phases complete
- GitHub/GitLab integration working
- >80% test coverage
- Published to PyPI and Docker Hub
- Complete documentation
